spring.application.name=product-service
## Port du serveur
#server.port=8082
#
## Configuration de la base de données MySQL
#spring.datasource.url=jdbc:mysql://localhost:3306/produit_db?createDatabaseIfNotExist=true
#spring.datasource.username=root
#spring.datasource.password=mi@nDR1s04
#
#spring.jpa.defer-datasource-initialization=true
#
## Configuration de JPA/Hibernate
#spring.jpa.hibernate.ddl-auto=update
#spring.jpa.show-sql=true

# Port du serveur - Commenté car Cloud Run injecte la variable d'environnement PORT,
# que Spring Boot utilise automatiquement. Garder cette ligne est sans danger mais non nécessaire sur Cloud Run.
# server.port=8082

# ===============================================
# Configuration pour la connexion à Cloud SQL
# ===============================================

# URL de la base de données utilisant le Cloud SQL Socket Factory.
# C'est la méthode recommandée et sécurisée pour se connecter depuis Cloud Run.
spring.datasource.url=jdbc:mysql://google/produit_db?socketFactory=com.google.cloud.sql.mysql.SocketFactory&cloudSqlInstance=gcp-project-20250702:europe-west1:microservices-db

# Utilisateur root de votre instance Cloud SQL.
spring.datasource.username=root

# Le mot de passe que vous avez défini lors de la création de l'instance Cloud SQL.
spring.datasource.password=mi@nDR1s04

# ===============================================
# Configuration de JPA/Hibernate
# ===============================================

# 'update' met à jour le schéma de la base de données (crée les tables si elles n'existent pas).
# C'est pratique pour le développement, mais pour la production, on préfère des outils comme Flyway ou Liquibase.
spring.jpa.hibernate.ddl-auto=update

# Affiche les requêtes SQL générées par Hibernate dans les logs. Utile pour le débogage.
spring.jpa.show-sql=true

# S'assure que data.sql est exécuté APRES la création des tables par Hibernate.
spring.jpa.defer-datasource-initialization=true
